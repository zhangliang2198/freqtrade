diff --git a/freqtrade/strategy/LLMStrategy.py b/freqtrade/strategy/LLMStrategy.py
index b0b550aae..2e210c2d9 100644
--- a/freqtrade/strategy/LLMStrategy.py
+++ b/freqtrade/strategy/LLMStrategy.py
@@ -112,6 +112,10 @@ class LLMStrategy(BaseStrategyWithSnapshot):
         if len(dataframe) < 1:
             return dataframe
 
+        # æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨èµ„é‡‘ï¼Œå¦‚æœæ²¡æœ‰èµ„é‡‘åˆ™è·³è¿‡åˆ†æï¼ˆèŠ‚çœ LLM æˆæœ¬ï¼‰
+        if not self._has_available_funds_for_entry():
+            return dataframe
+
         try:
             # æ„å»ºä¸Šä¸‹æ–‡
             portfolio_state = self._get_portfolio_state() if hasattr(self, 'wallets') else None
@@ -122,10 +126,12 @@ class LLMStrategy(BaseStrategyWithSnapshot):
                 strategy=self
             )
 
+            pair = metadata.get("pair", "UNKNOWN")
+
             # åˆ›å»ºè¯·æ±‚
             request = LLMRequest(
                 decision_point="entry",
-                pair=metadata["pair"],
+                pair=pair,
                 context=context
             )
 
@@ -137,11 +143,19 @@ class LLMStrategy(BaseStrategyWithSnapshot):
                 dataframe.loc[dataframe.index[-1], "enter_long"] = 1
                 confidence_tag = f"llm_entry_c{int(response.confidence * 100)}"
                 dataframe.loc[dataframe.index[-1], "enter_tag"] = confidence_tag
+                logger.info(
+                    f"ğŸ¯ LLM å…¥åœº {pair}: å¼€å¤š "
+                    f"(confidence={response.confidence:.2f}, reason={self._shorten_reason(response.reasoning)})"
+                )
 
             elif response.decision == "sell" and self.can_short:
                 dataframe.loc[dataframe.index[-1], "enter_short"] = 1
                 confidence_tag = f"llm_short_c{int(response.confidence * 100)}"
                 dataframe.loc[dataframe.index[-1], "enter_tag"] = confidence_tag
+                logger.info(
+                    f"ğŸ¯ LLM å…¥åœº {pair}: å¼€ç©º "
+                    f"(confidence={response.confidence:.2f}, reason={self._shorten_reason(response.reasoning)})"
+                )
 
             # 'hold' å†³ç­–è¡¨ç¤ºä¸å…¥åœº
 
@@ -207,6 +221,10 @@ class LLMStrategy(BaseStrategyWithSnapshot):
             if response.decision in ["exit", "sell"]:
                 # æˆªæ–­æ¨ç†ä»¥é€‚åº”é€€å‡ºåŸå› 
                 reason = response.reasoning[:30] if response.reasoning else "llm_exit"
+                logger.info(
+                    f"ğŸ›‘ LLM è§¦å‘ {pair} å‡ºåœº "
+                    f"(confidence={response.confidence:.2f}, reason={self._shorten_reason(response.reasoning)})"
+                )
                 return f"llm_{reason.replace(' ', '_')}"
 
         except Exception as e:
@@ -248,6 +266,11 @@ class LLMStrategy(BaseStrategyWithSnapshot):
         if not self.llm_engine:
             return proposed_stake
 
+        # æ£€æŸ¥å¯¹åº”æ–¹å‘æ˜¯å¦æœ‰å¯ç”¨èµ„é‡‘ï¼Œå¦‚æœæ²¡æœ‰åˆ™è·³è¿‡ LLM åˆ†æï¼ˆèŠ‚çœæˆæœ¬ï¼‰
+        if not self._has_available_funds_for_side(side):
+            logger.debug(f"â­ï¸  è·³è¿‡ {pair} {side.upper()} çš„ stake åˆ†æï¼š{side.upper()} è´¦æˆ·èµ„é‡‘ä¸è¶³")
+            return proposed_stake
+
         try:
             # å…ˆè·å–è´¦æˆ·çš„å®é™…å¯ç”¨ä½™é¢ï¼ˆè€ƒè™‘è´¦æˆ·åˆ†ç¦»æ¨¡å¼ï¼‰
             if self.strict_account_mode:
@@ -304,14 +327,22 @@ class LLMStrategy(BaseStrategyWithSnapshot):
             # è®¡ç®—è°ƒæ•´åçš„æŠ•å…¥
             adjusted_stake = proposed_stake * stake_multiplier
 
-            # åº”ç”¨æ¯æ¬¡å¼€å•çš„æœ€å¤§é¢åº¦é™åˆ¶ï¼ˆå¦‚æœé…ç½®äº†ï¼‰
+            # åº”ç”¨æ¯æ¬¡å¼€å•çš„æœ€å°/æœ€å¤§é¢åº¦é™åˆ¶ï¼ˆå¦‚æœé…ç½®äº†ï¼‰
             max_stake_config = point_config.get("max_stake_per_trade")
+            min_stake_config = point_config.get("min_stake_per_trade")
+
+            # è·å–è´¦æˆ·æ€»èµ„é‡‘ï¼ˆç”¨äºç™¾åˆ†æ¯”è®¡ç®—ï¼‰
+            if self.strict_account_mode:
+                total_balance = self.long_initial_balance if side == "long" else self.short_initial_balance
+            else:
+                total_balance = self.wallets.get_total(self.config["stake_currency"]) if hasattr(self, 'wallets') and self.wallets else available_balance
+
+            # åº”ç”¨æœ€å¤§é¢åº¦é™åˆ¶
             if max_stake_config:
                 mode = max_stake_config.get("mode", "percent")
                 value = max_stake_config.get("value", 0)
 
                 if mode == "fixed":
-                    # å›ºå®šé‡‘é¢æ¨¡å¼
                     max_per_trade = float(value)
                     if adjusted_stake > max_per_trade:
                         logger.info(
@@ -321,16 +352,41 @@ class LLMStrategy(BaseStrategyWithSnapshot):
                         adjusted_stake = max_per_trade
 
                 elif mode == "percent":
-                    # ç™¾åˆ†æ¯”æ¨¡å¼ï¼šåŸºäºå¯ç”¨ä½™é¢
-                    max_per_trade = available_balance * (value / 100.0)
+                    # ç™¾åˆ†æ¯”æ¨¡å¼ï¼šåŸºäºæ€»èµ„é‡‘
+                    max_per_trade = total_balance * (value / 100.0)
                     if adjusted_stake > max_per_trade:
                         logger.info(
-                            f"ğŸ“Š {pair} å¼€å•é¢åº¦å—é™äºå¯ç”¨ä½™é¢çš„ {value}%: "
+                            f"ğŸ“Š {pair} å¼€å•é¢åº¦å—é™äºæ€»èµ„é‡‘çš„ {value}%: "
                             f"{adjusted_stake:.2f} -> {max_per_trade:.2f} USDT "
-                            f"({side.upper()} å¯ç”¨: {available_balance:.2f})"
+                            f"(æ€»èµ„é‡‘: {total_balance:.2f})"
                         )
                         adjusted_stake = max_per_trade
 
+            # åº”ç”¨æœ€å°é¢åº¦é™åˆ¶
+            if min_stake_config:
+                mode = min_stake_config.get("mode", "percent")
+                value = min_stake_config.get("value", 0)
+
+                if mode == "fixed":
+                    min_per_trade = float(value)
+                    if adjusted_stake < min_per_trade:
+                        logger.info(
+                            f"ğŸ“Š {pair} å¼€å•é¢åº¦ä½äºé…ç½®çš„å›ºå®šæœ€å°å€¼: "
+                            f"{adjusted_stake:.2f} -> {min_per_trade:.2f} USDT"
+                        )
+                        adjusted_stake = min_per_trade
+
+                elif mode == "percent":
+                    # ç™¾åˆ†æ¯”æ¨¡å¼ï¼šåŸºäºæ€»èµ„é‡‘
+                    min_per_trade = total_balance * (value / 100.0)
+                    if adjusted_stake < min_per_trade:
+                        logger.info(
+                            f"ğŸ“Š {pair} å¼€å•é¢åº¦ä½äºæ€»èµ„é‡‘çš„ {value}%: "
+                            f"{adjusted_stake:.2f} -> {min_per_trade:.2f} USDT "
+                            f"(æ€»èµ„é‡‘: {total_balance:.2f})"
+                        )
+                        adjusted_stake = min_per_trade
+
             # ç¡®ä¿åœ¨é™åˆ¶èŒƒå›´å†…
             if min_stake:
                 adjusted_stake = max(adjusted_stake, min_stake)
@@ -443,7 +499,7 @@ class LLMStrategy(BaseStrategyWithSnapshot):
             # è®¡ç®—è°ƒæ•´æŠ•å…¥
             adjustment_stake = trade.stake_amount * adjustment_ratio
 
-            # æ£€æŸ¥è°ƒæ•´æ˜¯å¦è¶³å¤Ÿæ˜¾è‘—
+            # æ£€æŸ¥è°ƒæ•´æ˜¯å¦è¶³å¤Ÿæ˜¾è‘—ï¼ˆä½¿ç”¨ Freqtrade çš„æœ€å°å€¼ï¼‰
             if min_stake and abs(adjustment_stake) < min_stake:
                 return None
 
@@ -451,6 +507,71 @@ class LLMStrategy(BaseStrategyWithSnapshot):
             if adjustment_stake > 0:
                 adjustment_stake = min(adjustment_stake, max_stake)
 
+            # åº”ç”¨ llm_config ä¸­é…ç½®çš„æœ€å°/æœ€å¤§é¢åº¦é™åˆ¶ï¼ˆåŠ ä»“æ—¶ï¼‰
+            if adjustment_stake > 0:
+                # ä» stake å†³ç­–ç‚¹é…ç½®ä¸­è·å–é™åˆ¶
+                stake_point_config = self.llm_engine.config.get("decision_points", {}).get("stake", {})
+
+                # åº”ç”¨æœ€å°é¢åº¦é™åˆ¶
+                min_stake_config = stake_point_config.get("min_stake_per_trade")
+                if min_stake_config:
+                    mode = min_stake_config.get("mode", "percent")
+                    value = min_stake_config.get("value", 0)
+
+                    if mode == "fixed":
+                        min_per_trade = float(value)
+                        if adjustment_stake < min_per_trade:
+                            logger.info(
+                                f"ğŸ“Š {trade.pair} åŠ ä»“é¢åº¦ä½äºé…ç½®çš„å›ºå®šæœ€å°å€¼: "
+                                f"{adjustment_stake:.2f} < {min_per_trade:.2f} USDTï¼Œå–æ¶ˆåŠ ä»“"
+                            )
+                            return None
+                    elif mode == "percent":
+                        # ç™¾åˆ†æ¯”æ¨¡å¼ï¼šåŸºäºè´¦æˆ·æ€»èµ„é‡‘
+                        side = "short" if trade.is_short else "long"
+                        if self.strict_account_mode:
+                            total_balance = self.long_initial_balance if side == "long" else self.short_initial_balance
+                        else:
+                            total_balance = self.wallets.get_total(self.config["stake_currency"]) if hasattr(self, 'wallets') and self.wallets else 0
+
+                        min_per_trade = total_balance * (value / 100.0)
+                        if adjustment_stake < min_per_trade:
+                            logger.info(
+                                f"ğŸ“Š {trade.pair} åŠ ä»“é¢åº¦ä½äºæ€»èµ„é‡‘çš„ {value}%: "
+                                f"{adjustment_stake:.2f} < {min_per_trade:.2f} USDTï¼Œå–æ¶ˆåŠ ä»“"
+                            )
+                            return None
+
+                # åº”ç”¨æœ€å¤§é¢åº¦é™åˆ¶
+                max_stake_config = stake_point_config.get("max_stake_per_trade")
+                if max_stake_config:
+                    mode = max_stake_config.get("mode", "percent")
+                    value = max_stake_config.get("value", 0)
+
+                    if mode == "fixed":
+                        max_per_trade = float(value)
+                        if adjustment_stake > max_per_trade:
+                            logger.info(
+                                f"ğŸ“Š {trade.pair} åŠ ä»“é¢åº¦å—é™äºé…ç½®çš„å›ºå®šæœ€å¤§å€¼: "
+                                f"{adjustment_stake:.2f} -> {max_per_trade:.2f} USDT"
+                            )
+                            adjustment_stake = max_per_trade
+                    elif mode == "percent":
+                        # ç™¾åˆ†æ¯”æ¨¡å¼ï¼šåŸºäºè´¦æˆ·æ€»èµ„é‡‘
+                        side = "short" if trade.is_short else "long"
+                        if self.strict_account_mode:
+                            total_balance = self.long_initial_balance if side == "long" else self.short_initial_balance
+                        else:
+                            total_balance = self.wallets.get_total(self.config["stake_currency"]) if hasattr(self, 'wallets') and self.wallets else 0
+
+                        max_per_trade = total_balance * (value / 100.0)
+                        if adjustment_stake > max_per_trade:
+                            logger.info(
+                                f"ğŸ“Š {trade.pair} åŠ ä»“é¢åº¦å—é™äºæ€»èµ„é‡‘çš„ {value}%: "
+                                f"{adjustment_stake:.2f} -> {max_per_trade:.2f} USDT"
+                            )
+                            adjustment_stake = max_per_trade
+
             logger.info(
                 f"LLM è°ƒæ•´äº† {trade.pair} çš„æŒä»“: "
                 f"{'add' if adjustment_stake > 0 else 'reduce'} "
@@ -492,6 +613,11 @@ class LLMStrategy(BaseStrategyWithSnapshot):
         if not self.llm_engine:
             return proposed_leverage
 
+        # æ£€æŸ¥å¯¹åº”æ–¹å‘æ˜¯å¦æœ‰å¯ç”¨èµ„é‡‘ï¼Œå¦‚æœæ²¡æœ‰åˆ™è·³è¿‡ LLM åˆ†æï¼ˆèŠ‚çœæˆæœ¬ï¼‰
+        if not self._has_available_funds_for_side(side):
+            logger.debug(f"â­ï¸  è·³è¿‡ {pair} {side.upper()} çš„ leverage åˆ†æï¼š{side.upper()} è´¦æˆ·èµ„é‡‘ä¸è¶³")
+            return proposed_leverage
+
         try:
             # è·å–å½“å‰æ•°æ®æ¡†
             dataframe, _ = self.dp.get_analyzed_dataframe(pair, self.timeframe)
@@ -548,6 +674,144 @@ class LLMStrategy(BaseStrategyWithSnapshot):
             logger.error(f"LLM æ æ†å†³ç­–å¤±è´¥: {e}", exc_info=True)
             return proposed_leverage
 
+    def _shorten_reason(self, reasoning: Optional[str], limit: int = 80) -> str:
+        """
+        å°† LLM è¿”å›çš„æ¨ç†å‹ç¼©ä¸ºç®€çŸ­æ–‡æœ¬ç”¨äºæ—¥å¿—
+        """
+        if not reasoning:
+            return "æ— æ¨ç†"
+        reason = " ".join(str(reasoning).split())
+        return reason if len(reason) <= limit else f"{reason[:limit]}..."
+
+    def _has_available_funds_for_entry(self) -> bool:
+        """
+        æ£€æŸ¥æ˜¯å¦æœ‰å¯ç”¨èµ„é‡‘è¿›è¡Œå…¥åœºåˆ†æ
+
+        è€ƒè™‘è´¦æˆ·åˆ†ç¦»å’Œåšç©ºåŠŸèƒ½ï¼Œå¦‚æœæ‰€æœ‰è´¦æˆ·éƒ½æ²¡æœ‰å¯ç”¨èµ„é‡‘åˆ™è¿”å› False
+
+        Returns:
+            å¦‚æœè‡³å°‘æœ‰ä¸€ä¸ªæ–¹å‘æœ‰å¯ç”¨èµ„é‡‘åˆ™è¿”å› True
+        """
+        if not hasattr(self, 'wallets') or not self.wallets:
+            # æ²¡æœ‰é’±åŒ…ä¿¡æ¯ï¼Œé»˜è®¤å…è®¸åˆ†æ
+            return True
+
+        try:
+            # ä» llm_config ä¸­è·å–æœ€å°å¯ç”¨ä½™é¢ç™¾åˆ†æ¯”é˜ˆå€¼
+            llm_config = self.config.get("llm_config", {})
+            fund_check_config = llm_config.get("fund_check", {})
+            min_balance_pct = fund_check_config.get("min_available_balance_pct", 1.0) * 100
+
+            # å¦‚æœå¯ç”¨äº†è´¦æˆ·åˆ†ç¦»
+            if hasattr(self, 'account_enabled') and self.account_enabled:
+                long_available = self.get_account_available_balance("long") if hasattr(self, 'get_account_available_balance') else 0
+                short_available = self.get_account_available_balance("short") if hasattr(self, 'get_account_available_balance') else 0
+
+                # è®¡ç®—æœ€å°é˜ˆå€¼ï¼ˆåŸºäºåˆå§‹ä½™é¢çš„ç™¾åˆ†æ¯”ï¼‰
+                long_initial = float(self.long_initial_balance) if hasattr(self, 'long_initial_balance') else 0
+                short_initial = float(self.short_initial_balance) if hasattr(self, 'short_initial_balance') else 0
+
+                long_threshold = long_initial * (min_balance_pct / 100.0)
+                short_threshold = short_initial * (min_balance_pct / 100.0)
+
+                # æ£€æŸ¥åšå¤šè´¦æˆ·
+                has_long_funds = long_available >= long_threshold
+
+                # æ£€æŸ¥åšç©ºè´¦æˆ·ï¼ˆå¦‚æœæ”¯æŒåšç©ºï¼‰
+                has_short_funds = short_available >= short_threshold if self.can_short else False
+
+                # è‡³å°‘ä¸€ä¸ªæ–¹å‘æœ‰èµ„é‡‘
+                if has_long_funds or has_short_funds:
+                    return True
+                else:
+                    logger.debug(
+                        f"â­ï¸  è·³è¿‡å…¥åœºåˆ†æï¼šæ‰€æœ‰è´¦æˆ·èµ„é‡‘ä¸è¶³ "
+                        f"(å¤šå¤´å¯ç”¨: {long_available:.2f}/{long_threshold:.2f}, "
+                        f"ç©ºå¤´å¯ç”¨: {short_available:.2f}/{short_threshold:.2f}, "
+                        f"é˜ˆå€¼: {min_balance_pct}%)"
+                    )
+                    return False
+            else:
+                # éè´¦æˆ·åˆ†ç¦»æ¨¡å¼ï¼šæ£€æŸ¥æ€»å¯ç”¨ä½™é¢
+                stake_currency = self.config.get("stake_currency", "USDT")
+                available = self.wallets.get_free(stake_currency)
+
+                # è·å–åˆå§‹ä½™é¢
+                try:
+                    initial_balance = self.wallets.get_starting_balance()
+                except Exception:
+                    initial_balance = self.wallets.get_total(stake_currency)
+
+                min_threshold = initial_balance * (min_balance_pct / 100.0)
+
+                if available >= min_threshold:
+                    return True
+                else:
+                    logger.debug(
+                        f"â­ï¸  è·³è¿‡å…¥åœºåˆ†æï¼šèµ„é‡‘ä¸è¶³ "
+                        f"(å¯ç”¨: {available:.2f}/{min_threshold:.2f}, é˜ˆå€¼: {min_balance_pct}%)"
+                    )
+                    return False
+
+        except Exception as e:
+            logger.warning(f"æ£€æŸ¥èµ„é‡‘å¯ç”¨æ€§å¤±è´¥: {e}")
+            # å‡ºé”™æ—¶é»˜è®¤å…è®¸åˆ†æ
+            return True
+
+    def _has_available_funds_for_side(self, side: str) -> bool:
+        """
+        æ£€æŸ¥æŒ‡å®šæ–¹å‘æ˜¯å¦æœ‰å¯ç”¨èµ„é‡‘
+
+        Args:
+            side: äº¤æ˜“æ–¹å‘ ("long" æˆ– "short")
+
+        Returns:
+            å¦‚æœæŒ‡å®šæ–¹å‘æœ‰å¯ç”¨èµ„é‡‘åˆ™è¿”å› True
+        """
+        if not hasattr(self, 'wallets') or not self.wallets:
+            # æ²¡æœ‰é’±åŒ…ä¿¡æ¯ï¼Œé»˜è®¤å…è®¸åˆ†æ
+            return True
+
+        try:
+            # ä» llm_config ä¸­è·å–æœ€å°å¯ç”¨ä½™é¢ç™¾åˆ†æ¯”é˜ˆå€¼
+            llm_config = self.config.get("llm_config", {})
+            fund_check_config = llm_config.get("fund_check", {})
+            min_balance_pct = fund_check_config.get("min_available_balance_pct", 1.0)
+
+            # å¦‚æœå¯ç”¨äº†è´¦æˆ·åˆ†ç¦»
+            if hasattr(self, 'account_enabled') and self.account_enabled:
+                if hasattr(self, 'get_account_available_balance'):
+                    available = self.get_account_available_balance(side)
+                else:
+                    available = 0
+
+                # è·å–å¯¹åº”è´¦æˆ·çš„åˆå§‹ä½™é¢
+                if side == "long":
+                    initial = float(self.long_initial_balance) if hasattr(self, 'long_initial_balance') else 0
+                else:
+                    initial = float(self.short_initial_balance) if hasattr(self, 'short_initial_balance') else 0
+
+                min_threshold = initial * (min_balance_pct / 100.0)
+            else:
+                # éè´¦æˆ·åˆ†ç¦»æ¨¡å¼ï¼šä½¿ç”¨æ€»å¯ç”¨ä½™é¢
+                stake_currency = self.config.get("stake_currency", "USDT")
+                available = self.wallets.get_free(stake_currency)
+
+                # è·å–åˆå§‹ä½™é¢
+                try:
+                    initial = self.wallets.get_starting_balance()
+                except Exception:
+                    initial = self.wallets.get_total(stake_currency)
+
+                min_threshold = initial * (min_balance_pct / 100.0)
+
+            return available >= min_threshold
+
+        except Exception as e:
+            logger.warning(f"æ£€æŸ¥ {side} æ–¹å‘èµ„é‡‘å¯ç”¨æ€§å¤±è´¥: {e}")
+            # å‡ºé”™æ—¶é»˜è®¤å…è®¸åˆ†æ
+            return True
+
     def _get_portfolio_state(self) -> Optional[dict]:
         """
         è·å–å½“å‰æŠ•èµ„ç»„åˆçŠ¶æ€ä½œä¸ºä¸Šä¸‹æ–‡
